## Что такое полиморфизм?

**Полиморфизм**  (от греч. *poly* — много, *morph* — форма) означает "многообразие форм". В объектно-ориентированном программировании (ООП) полиморфизм – это способность единого интерфейса или имени метода работать с разными типами данных и объектами, предоставляя разную реализацию. Проще говоря, один и тот же вызов может приводить к разному поведению в зависимости от того, **объект какого конкретного класса обрабатывает этот вызов** .
**Простая аналогия из реальной жизни:**  Представьте актёра в театре. Один и тот же человек (актёр) может играть разные роли – короля, шута, героя – и в каждой роли он ведёт себя по-разному, хотя это тот же самый человек. Для зрителей достаточно знать, что перед ними актёр, а какую конкретно роль он исполняет – определяет ситуация (спектакль). В программировании полиморфизм позволяет нам обращаться с объектом через **общий тип (роль)** , а реальное поведение определяется конкретным классом объекта (конкретной ролью).
Ещё пример: человек может быть одновременно и сыном, и родителем, и сотрудником. В каждом из этих контекстов один и тот же человек действует по-разному. Аналогично, в Java объект может принадлежать классу `Animal`, но конкретное поведение (скажем, издаваемый звук) зависит от того, является ли этот объект на самом деле `Dog` или `Cat`.
**Итого:**  Полиморфизм – один из основных принципов ООП, позволяющий писать более гибкий и расширяемый код. Он часто достигается через механизм **наследования** : создавая иерархию классов, где дочерние классы переопределяют поведение, мы можем работать с ними через ссылку родительского типа, не зная деталей каждой реализации.

## Статический (компиляторный) vs. динамический (время выполнения) полиморфизм

В Java принято выделять **две формы полиморфизма** :

- **Статический полиморфизм**  (compile-time polymorphism) – определяется во время компиляции. В Java это обычно реализуется через **перегрузку методов** . Решение о том, какую версию метода вызвать, принимается компилятором на основе типов аргументов. Другими словами, имя метода одно, но может быть несколько реализаций с разными параметрами, и выбор происходит еще до запуска программы.

- **Динамический полиморфизм**  (runtime polymorphism) – определяется во время выполнения программы. Достигается через **переопределение методов**  в наследуемых классах. Какой метод выполнить, решается *динамически* в момент вызова, исходя из реального типа объекта в памяти, даже если мы обращаемся к нему через ссылку родительского типа. Это также называют **динамическим связыванием**  методов.


Обе формы полиморфизма позволяют использовать единый интерфейс для разных реализаций, но отличаются временем, когда определяется конкретная реализуемая форма метода. Рассмотрим каждую подробнее и приведём примеры.


### Статический полиморфизм (перегрузка методов)

**Перегрузка методов**  – это определение нескольких методов с **одинаковым именем**  в одном классе, но с **разными списками параметров**  (различается количество параметров или их типы). Перегрузка *не требует наследования* – методы находятся в одном классе. Выбор конкретного метода из перегруженных происходит при компиляции, исходя из того, какие аргументы переданы в вызове.
Простой пример перегрузки методов – класс, вычисляющий сумму чисел. Определим два метода `sum`: один складывает два числа, другой – три:


```java
public class Adder {
    // Метод для суммы двух целых чисел
    public int sum(int a, int b) {
        return a + b;
    }

    // Перегруженный метод для суммы трёх целых чисел
    public int sum(int a, int b, int c) {
        return a + b + c;
    }

    public static void main(String[] args) {
        Adder adder = new Adder();
        int result1 = adder.sum(5, 11);      // вызовется первая версия sum(int, int)
        int result2 = adder.sum(1, 8, 11);   // вызовется вторая версия sum(int, int, int)
        System.out.println("Сумма двух чисел: " + result1);
        System.out.println("Сумма трёх чисел: " + result2);
    }
}
```

**Вывод при запуске:**


```
Сумма двух чисел: 16  
Сумма трёх чисел: 20
```

Здесь обе функции называются `sum`, но компилятор знает, какую из них вызывать, по количеству аргументов. Таким образом, перегрузка – пример полиморфизма, где **один метод может иметь много форм**  (вариантов), но конкретная форма выбирается на этапе компиляции.
Обратите внимание: в Java *тип возвращаемого значения не учитывается* при перегрузке. Методы должны различаться параметрами. Также перегруженные методы могут иметь разную логику, но обычно выполняют схожую концептуальную задачу (как в примере – оба суммируют числа, но разное их количество).

### Динамический полиморфизм (переопределение методов)

**Динамический полиморфизм**  достигается через механизм **переопределения методов**  при наследовании. *Переопределение* означает, что дочерний класс предоставляет свою реализацию метода, который объявлен в классе-родителе. При этом вызов такого метода через ссылку родительского типа будет выполняться в соответствии с фактическим типом объекта (т.е. будет вызвана версия метода из дочернего класса, если объект является экземпляром дочернего класса).
Это поведение обеспечивает **виртуальность методов** : в Java все нестатические методы по умолчанию виртуальные, то есть выбор реализации происходит на этапе выполнения программы.
Рассмотрим пример с животными. Определим базовый класс `Animal` с методом `sound()` (звук, издаваемый животным). Затем создадим подклассы `Dog` (собака) и `Cat` (кошка), которые переопределяют метод `sound()` по-своему:


```java
class Animal {
    public void sound() {
        System.out.println("Какой-то звук");
    }
}

class Dog extends Animal {
    @Override
    public void sound() {
        System.out.println("Гав!");
    }
}

class Cat extends Animal {
    @Override
    public void sound() {
        System.out.println("Мяу!");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal a1 = new Animal();   // объект типа Animal
        Animal a2 = new Dog();     // upcasting: объект Dog, но ссылка типа Animal
        Animal a3 = new Cat();     // upcasting: объект Cat, но ссылка типа Animal

        a1.sound();   // вызов Animal.sound()
        a2.sound();   // вызов Dog.sound() благодаря полиморфизму
        a3.sound();   // вызов Cat.sound() благодаря полиморфизму
    }
}
```

**Вывод при выполнении:**


```
Какой-то звук  
Гав!  
Мяу!
```

Объяснение: хотя переменные `a2` и `a3` объявлены как тип `Animal`, на самом деле они указывают на объекты `Dog` и `Cat` соответственно. При вызове `a2.sound()` JVM видит, что реальный объект – это `Dog`, и динамически вызывает именно `Dog.sound()`. Аналогично для `a3.sound()`. Это и есть полиморфизм времени выполнения: **метод определяется по реальному типу объекта в момент вызова** .

Такой подход позволяет писать код, не привязанный к конкретным классам. Например, мы могли бы написать метод:



```java
public void makeAnimalSound(Animal animal) {
    animal.sound();
}
```

Этот метод принимает `Animal`, но мы можем передать туда `new Dog()` или `new Cat()` – и он корректно вызовет соответствующую реализацию `sound()` для каждого подтипа. Добавление новых видов животных (новых подклассов) не требует изменения метода `makeAnimalSound`, он уже готов работать с любым `Animal` или его потомком. Это демонстрирует мощь полиморфизма в создании расширяемых архитектур.

## Ключевые понятия, связанные с полиморфизмом


При работе с полиморфизмом в Java важно понимать несколько связанных концепций и ключевых слов:


- **
  `instanceof`**  – оператор для проверки принадлежности объекта к определённому типу. Возвращает `true`, если объект является экземпляром указанного класса **или его подкласса** . Например: `if (animal instanceof Dog) { ... }` проверит, является ли объект, на который ссылается `animal`, типом `Dog` (или наследником `Dog`). Обычно `instanceof` используют перед приведением типов (downcasting), чтобы избежать ошибки ClassCastException. Однако частое использование `instanceof` может указывать на неэффективное применение полиморфизма – в идеале логику различий лучше помещать внутрь самих классов в виде переопределённых методов, вместо того чтобы снаружи проверять типы.

- **
  `super`**  – ключевое слово, ссылающееся на сущность родительского класса. Его основные применения:

    - Вызов конструктора родителя: `super(...);` должно быть первой строкой в конструкторе подкласса, если нужно явно вызвать конструктор базового класса с параметрами.

    - Вызов метода родителя: внутри переопределённого метода можно вызвать реализацию родителя через `super.methodName()`. Это полезно, когда хотим расширить поведение родительского метода, а не полностью заменить. Например, в классе `Dog` можно было бы реализовать `sound()` как:


```java
@Override
public void sound() {
    super.sound();        // вызвать Animal.sound()
    System.out.println("Гав!");
}
```

В таком случае при вызове `dog.sound()` сначала напечатается `"Какой-то звук"`, затем `"Гав!"`. Ключевое слово `super` помогает обратиться к версии метода из суперкласса.

- **Виртуальные методы**  – концепция, означающая, что выбор реализации метода происходит во время выполнения на основе реального типа объекта. В Java **все нестатические методы являются виртуальными**  по умолчанию. Это значит, что если метод может быть переопределён в наследниках, JVM будет вызывать ту реализацию, которая соответствует реальному объекту. Исключения: методы, объявленные как `private` или `final`, а также статические методы – они **не виртуальные**  (не могут быть переопределены или их поведение не изменяется динамически). Статические методы относятся к классу, а не к объекту, поэтому при вызове `SomeClass.staticMethod()` не происходит динамического выбора – метод определяется на этапе компиляции по типу ссылки/класса.

- **
  Аннотация `@Override`**  – специальная аннотация, которую принято ставить над методом в классе-потомке, если этот метод предназначен для переопределения родительского. Она не влияет на выполнение программы напрямую, но **помогает компилятору**  и разработчику: компилятор проверит, что такой метод действительно существует в суперклассе (или интерфейсе) с точно такой же сигнатурой. Если вы опечатались или неправильно указали параметры, компилятор выдаст ошибку. Это защищает от распространённой ошибки, когда метод задумывался как переопределение, но на деле является перегруженным из-за несовпадения сигнатур. Всегда ставьте `@Override` при переопределении – это хорошая практика, делающая код понятнее и защищающая от ошибок.


## Где и зачем использовать полиморфизм


Полиморфизм – мощный инструмент, который делает код гибким и легко расширяемым. Ниже приведены практические ситуации, где он особенно полезен:


- **Упрощение работы с группой разных объектов.**  Если у вас есть несколько классов, реализующих общий интерфейс или имеющих общего предка, вы можете обрабатывать их одинаково. Например, можно создать список `List<Animal>` и поместить туда и `Dog`, и `Cat`, и других потомков `Animal`. При обходе списка и вызове метода `sound()` каждый объект будет вести себя согласно своей природе. Код, работающий с коллекцией животных, не нужно менять при добавлении новых видов – достаточно создать новый класс, унаследованный от `Animal`, и реализовать в нём необходимые методы.

- **Принцип "программируй на уровне интерфейса, а не реализации".**  В Java часто используют интерфейсы или абстрактные классы для задания общего контракта, а затем подставляют разные реализации. Например, метод может возвращать интерфейс `List`, а фактически может быть использован `ArrayList` или `LinkedList` – для вызывающего кода это не имеет значения, он работает с `List`. Это позволяет легко менять реализации (например, заменить одну базу данных на другую, один алгоритм на другой) без изменения самого кода, использующего эти интерфейсы.

- **Повторное использование кода и уменьшение дублирования.**  Общий функционал можно вынести в базовый класс, а отличия реализовать в подклассах. Благодаря этому, вместо копирования и видоизменения похожего кода, вы пишете его один раз в родительском классе, а потомки переопределяют только то, что необходимо изменить. Это соответствует принципу **DRY (Don’t Repeat Yourself)**  и облегчает сопровождение: исправив ошибку или изменив поведение в базовом классе, вы автоматически влияют на всех наследников.

- **Расширяемость и поддержка.**  Код, использующий полиморфизм, как правило, **легче расширять** . Добавление новых классов (наследников) обычно не требует изменения существующих классов, которые с ними работают. Например, ваш игровой движок может иметь класс `GameObject` с методом `update()`. Разработчики могут добавлять новые типы объектов (NPC, препятствия, бонусы), наследуя `GameObject` и переопределяя `update()` для их уникального поведения. Существующая логика, которая вызывает `gameObject.update()` для всех объектов, начнет работать с новыми типами без изменений.

- **Использование полиморфизма в шаблонах проектирования.**  Многие паттерны проектирования (например, *Strategy*, *State*, *Factory Method*, *Template Method*) основаны на полиморфизме. Они позволяют подставлять разные реализации определенного поведения в процессе выполнения, следуя принципам SOLID (в частности, принципу подстановки Барбары Лисков и открытности/закрытости).


В целом, применять полиморфизм стоит тогда, когда у вас есть несколько объектов, которым нужно предоставить единый интерфейс взаимодействия, но с разным внутренним поведением. Это приводит к более чистому, понятному коду, который проще модифицировать и расширять по мере роста требований.


## Возможные ошибки и подводные камни


Несмотря на пользу полиморфизма, начинающие разработчики могут столкнуться с некоторыми трудностями и распространёнными ошибками при его использовании:


- **Путаница между перегрузкой и переопределением.**  Перегрузка (static polymorphism) и переопределение (dynamic polymorphism) – разные вещи. Перегрузка происходит в пределах одного класса (или его наследников, но как новые методы, а не замена старых) и выбирается при компиляции. Переопределение же подразумевает ту же сигнатуру метода в наследнике, и выбор реализации на этапе выполнения. Новички иногда думают, что изменив тип параметра, они "переопределили" метод – но на самом деле они создали перегруженную версию. **Совет:**  Всегда используй `@Override` при переопределении – тогда такой ошибки не произойдёт, компилятор подскажет.

- **
  Отсутствие аннотации `@Override`.**  Как упоминалось, если забыть написать `@Override` над методом-потомком, можно случайно ошибиться в сигнатуре (например, немного другое имя параметра, тип или количество параметров) и не заметить, что метод не override-ит родительский, а перегружает его. Это приведёт к тому, что полиморфизм не сработает, и код может вести себя не так, как ожидается. Всегда помечайте переопределяемые методы `@Override`.

- **Попытка переопределить то, что не является виртуальным.**  В Java нельзя полиморфно переопределить `static` методы и конструкторы. Если вы объявите в подклассе метод с той же сигнатурой, что и статический метод родителя, это *не* переопределение, а **скрытие метода**  (method hiding). Вызов статического метода определяется по типу ссылки во время компиляции. Подобно этому, поля тоже не участвуют в полиморфизме: если у родителя и потомка есть поле с одинаковым именем, ссылки типа родителя будут обращаться к своему (родительскому) полю. Учтите эти моменты, чтобы не удивляться, почему "переопределённый" static-метод или поле не ведут себя как ожидается.

- **Неверное приведение типов (downcasting) без проверки.**  Если у вас есть ссылка родительского типа, фактически указывающая на объект дочернего класса, иногда возникает потребность привести её к типу дочернего класса, чтобы вызвать методы, специфичные для него. Например:


```java
Animal animal = new Dog();
// animal.bark(); // ошибка компиляции, у Animal нет метода bark()
if (animal instanceof Dog) {
    Dog dog = (Dog) animal;
    dog.bark(); // теперь можно вызвать метод, специфичный для Dog
}
```

Здесь метод `bark()` определён только у `Dog`. Нужно сначала проверить через `instanceof`, что `animal` действительно ссылается на `Dog`, и только потом приводить. Если сделать приведение без проверки, а объект окажется не того типа, это вызовет исключение времени выполнения (`ClassCastException`). **Подводный камень:**  чрезмерное использование downcast/instanceof может быть признаком проблемы в дизайне – старайтесь строить логику так, чтобы обходиться вызовом переопределённых методов через общий тип, без ручного распознавания типов.

- **Виртуальный вызов методов в конструкторе.**  Особый случай: если вы вызываете переопределяемый метод из конструктора базового класса, то при создании объекта дочернего класса будет вызвана **переопределённая версия метода**  (динамический полиморфизм работает даже в конструкторе). Но к моменту вызова конструктор потомка ещё не завершился, и его поля еще не инициализированы полностью. Это может привести к неожиданному поведению или ошибкам. **Рекомендация:**  избегайте вызывать виртуальные методы (те, которые могут быть переопределены) внутри конструкторов – либо делайте их `final` в базовом классе, либо помечайте как `private` (что автоматически делает метод невиртуальным).

- **Снижение читаемости при чрезмерном наследовании.**  Хотя полиморфизм – вещь хорошая, чрезмерно глубокая иерархия классов или слишком динамическое поведение могут затруднить понимание кода. Разработчику, читающему код, может быть не сразу ясно, какая реализация метода вызовется, особенно если наследование многоуровневое. Это не столько "ошибка", сколько предупреждение: придерживайтесь разумной простоты. Используйте ясные имена и понятную архитектуру. Иногда вместо наследования имеет смысл использовать композицию объектов.

- **Производительность и полиморфизм.**  Динамический вызов методов теоретически медленнее прямого вызова, но в современных JVM разница обычно незначительна из-за оптимизаций (JIT-компиляция и т.п.). Однако, например, в критических местах (внутри огромных циклов) бесконечные виртуальные вызовы могут оказаться узким местом. Обычно же писать код надо в первую очередь понятным и гибким, а оптимизировать – только обнаружив реальную проблему. Просто помните, что полиморфизм добавляет небольшие накладные расходы.
