- **Теория**  — важные понятия, формулы, «как это работает внутри».

- **Практика**  — задачи, которые помогут закрепить именно эти знания



---


1. Одномерные массивы + циклы (`work_07_03_2025`)

### Теория


- **Структура данных** : фиксированная длина, непрерывный участок памяти → O(1) доступ по индексу.

- **Инициализация** : `int[] a = new int[10];` или `int[] a = {3, 5, 8};`.

- **Ключевые операции** :

    - линейный проход `for (int i = 0; …)` — O(n);

    - поиск min/max, подсчёт суммы, разворот in‑place (`a[i] ↔ a[n‑1‑i]`).

- **Память** : для `int` — 4 байта × N.


### Практика


2. Напишите метод `boolean isSorted(int[] arr)` — возвращает `true`, если массив строго неубывающий, без сортировки.

4. Реализуйте `void rotateLeft(int[] arr, int k)` — циклически смещает массив влево на *k* позиций за O(n).



---


2. `ArrayList` и `Iterator.remove()` (`work_04_03_2025`)

### Теория


- **
  `ArrayList`**  — динамический массив: при переполнении создаётся новый массив ≈ 1.5× больше, все элементы копируются.

- **
  `Iterator`**  помогает безопасно удалять элементы во время обхода:


```java
Iterator<Student> it = list.iterator();
while (it.hasNext()) {
    if (it.next().getMark() < 60) it.remove();
}
```

Вызов `list.remove()` внутри того же цикла вызовет `ConcurrentModificationException`, потому что модификация обходит внутренний мод‑счётчик коллекции.


### Практика

Напишите метод `List<String> topN(List<String> words, int n)` — он удаляет из списка все строки длиной ≤ 3 символа через `Iterator`, а затем оставшиеся сортирует по длине убыв. и возвращает `n` первых.


---


3. Тернарный оператор, простые методы (`work_13_02_2025`)

### Теория


- Синтаксис: `condition ? valueIfTrue : valueIfFalse;`

- Интерпретируется как короткий `if/else`, выражение должно вернуть значение.

- Читаемость: хорош для очевидных, коротких условий.


### Практика

В классе `DiscountService` реализуйте метод


```java
double finalPrice(double price, boolean isVip)  // vip получают −7 %
```

с одной строкой тернарного оператора (без `if`).


---


4. Двумерные массивы, простые числа, `switch` (`work_14_03_2025`)

### Теория


- **Матричный доступ** : `int[][] m = new int[rows][cols];` – хранится как массив ссылок на строки.

- **Вложенные циклы** : внеш­ний → строки, внутрен­ний → столбцы.

- **Проверка простоты** : делители от 2 до √n, остановка на первом найденном.

- **
  `switch` (JDK 17)** :


```java
switch (command) {
    case "ADD"  -> add();
    case "EXIT" -> System.exit(0);
    default     -> System.out.println("?");
}
```


### Практика


Сделайте меню‑консоль «Магазин матриц»:


- `1) Заполнить случайно`

- `2) Вывести`

- `3) Найти все простые элементы`

- `4) Сложить с другой матрицей`

- `0) Выход`



---


5. Области видимости, `static`, default‑значения (`work_11_02_2025`, `work_21_02_2025`)

### Теория


- **Локальные переменные**  обязаны быть явно инициализированы; живут до конца блока `{}`.

- **Поля**  получают default: `0/0.0/false/null`.

- **
  `static`**  — члены класса, одна копия на JVM‑процесс; доступны без создания объекта.

- Порядок инициализации: static‑поля → static‑блоки → экземпляр‑поля → конструктор.


### Практика

Создайте класс `CounterDemo` с полем‑счётчиком объектов (`static int created`) и методом `void show()`; в `main()` создайте 5 экземпляров, в каждом вызовите `show()`, потом напечатайте `CounterDemo.created`.


---


6. Наследование, абстракции, полиморфизм (`work_09_04_2025`)

### Теория


- **«is‑a»** : `class Dog extends Animal`.

- **Абстрактный класс**  — не создаётся напрямую; содержит абстрактные методы без тела.

- **Позднее связывание**  (`virtual dispatch`): вызов `obj.method()` выбирает реализацию по фактическому классу во время исполнения.

- **Liskov Substitution** : в коде, который ждёт `Animal`, можно безопасно подставить `Dog`.


### Практика


Моделируйте парк аттракционов:


- `abstract Attraction` (`ride()`, `capacity()`).

- Подклассы `RollerCoaster`, `Carousel`, `HauntedHouse`.

- В `Park` массив `Attraction[]`; метод `openAll()` вызывает `ride()` у каждой и суммирует общую пропускную способность.



---


7. Коллекции и транзакции (`work_16_04_25`)

### Теория


- **
  `List` vs `ArrayList`** : интерфейс и реализация.

- Методы: `add`, `remove(index)`, `removeIf(Predicate)`, `stream().filter().map().collect()`.

- **Big‑O** : `add()` в конец амортизированно O(1); удаление/вставка — O(n) из‑за копирования.


### Практика

Реализуйте `TransactionService` с методами:


```java
double average(String currency);
List<Transaction> between(LocalDate from, LocalDate to);
Map<String, Double> groupByType();  // "FOOD" -> сумма
```



---


8. Паттерны Strategy и Command (`work_18_04_2025`)

### Теория


- **Strategy** : выбираем алгоритм во время исполнения; контекст содержит ссылку на интерфейс.


```java
interface PayStrategy { void pay(double amount); }
class CardPay implements PayStrategy { … }
```

- **Command** : инкапсуляция запроса как объекта; легко делать undo/redo.


```java
interface Command { void execute(); void undo(); }
```


### Практика


Сделайте текстовый редактор:


- Команды `Insert`, `Delete`, `Replace`;

- `CommandHistory` со стеком undo/redo;

- `Editor` хранит `StringBuilder text`.



---


9. Самодельный стек на массиве (`work_26_03_2025`)

### Теория


- Операции: `push`, `pop`, `peek`, `isEmpty`; все — O(1).

- Реализация на массиве: индекс `top` указывает, где положить/взять элемент.

- Переполнение — увеличиваем массив или бросаем исключение.

- Вариант «стек с минимумом» — хранить второй стек с текущим минимумом.


### Практика

Расширьте `MyStack<E>`:

- метод `E popMany(int k)` — достаёт сразу k элементов (если есть);

- `void reverse()` — разворачивает стек за O(n) без доп.памяти.



---


10. Примитивы vs ссылки, инкремент, `switch`‑тонкости (`work_28_03_2025`)

### Теория


- **Примитив**  хранит само значение в стеке/куче; **ссылочный**  — адрес на объект в куче.

- `++i` — pre‑increment: сначала +1, потом используется; `i++` — post‑increment.

- В `switch` на `String` используется `hashCode()`+`equals()`; начиная с JDK 17 есть `switch`‑выражения.


### Практика

Напишите игру «Угадай число» на диапазон 1…100: пользователь вводит число, программа возвращает `HIGHER`, `LOWER`, `WIN` через `switch`‑выражение.


---


11. Многофайловый проект StepTracker (`projects`)

### Теория


- **SRP** : `StepTracker` — бизнес‑логика; `MonthData` — хранилище; `Converter` — утилита.

- **Меню**  в консоли — цикл `while(flag)` + `switch` → MVC «по‑минимальному».

- **Персистентность**  может быть расширена: сериализация / файлы / JDBC.


### Практика


Сделайте экспорт статистики в CSV:



```java
void saveMonth(int month, Path file);
```

формат: `day;steps;distance_km;kcal`.


---